## 문제)
길이가 N인 자연수로 이루어진 수열이 주어집니다. 수열의 각 항 사이에 끼워넣을 N-1개의
연산자가 주어집니다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있습니
다.
수열의 순서는 그대로 유지한 채 각 항사이에 N-1개의 연산자를 적절히 배치하면 다양한 수
식이 나옵니다.
예를 들면
수열이 1 2 3 4 5이고 덧셈(+) 1개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 일 때
만들 수 있는 수식은 많은 경우가 존재한다.
그 중 1+2*3-4/5와 같이 수식을 만들었다면 수식을 계산하는 결과는 연산자 우선순위를 따지
지 않고 맨 앞쪽 연산자부터 차례로 계산한다. 수식을 계산한 결과는 1이다.
N길이의 수열과 N-1개의 연산자가 주어지면 만들 수 있는 수식들 중에서 연산한 결과가 최대
인것과 최소인것을 출력하는 프로그램을 작성하세요.

### 입력 설명
첫째 줄에 수의 개수 N(2 ≤ N ≤ 10)가 주어진다. 둘째 줄에 수열이 주어진다. 수열의 값은
100까지이다. 셋째 줄에는 연산자의 각 개수가 차례대로 덧셈(+) 개수, 뺄셈(-) 개수, 곱셈(×)
개수, 나눗셈(÷) 개수로 주어진다. 연산자의 총 개수는 N-1이다.

### 출력 설명
첫째 줄에는 최댓값을, 둘째 줄에는 최솟값을 출력한다. 

### 입력 예제
3\
5 3 8\
1 0 1 0

### 출력 예제
64
23

### 모범 답안
``` Cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[101], op[4], maxi, mini;

void DFS(int L, int res) {
    if (L == n) {
        if (res > maxi) maxi = res;
        if (res < mini) mini = res;
    }
    else {
        if (op[0] > 0) {
            op[0]--;
            DFS(L + 1, res + a[L]); // + 연산자 사용
            op[0]++;
        }
        if (op[1] > 0) {
            op[1]--;
            DFS(L + 1, res - a[L]);
            op[1]--;
        }
        if (op[2] > 0) {
            op[2]--;
            DFS(L + 1, res * a[L]);
            op[2]++;
        }
        if (op[3] > 0) {
            op[3]--;
            DFS(L + 1, res / a[L]);
            op[3]++;
        }
    }
}

int main() {
    FILE* fp = nullptr;
    freopen_s(&fp, "input.txt", "rt", stdin);
    int i = 0;
    cin >> n;
    for (i = 0; i < 4; i++) {
        cin >> a[i];
    }
    for (i = 0; i < 4; i++) {
        cin >> op[i];
    }
    DFS(1, a[0]); // 2번째 숫자부터 적용하기 위해 1을 넘김
    return 0;
}
```

### 회고
- DFS, BFS 관련 문제를 처음 접하면 어려운 게 사실이라고 한다.
- 사실 개념이 너무 안잡혀서 따라 치면서 익숙해 지려고 먼저 노력 중인데 
- 듣던 중 너무 위로가 되어서 회고로 남겨본다.