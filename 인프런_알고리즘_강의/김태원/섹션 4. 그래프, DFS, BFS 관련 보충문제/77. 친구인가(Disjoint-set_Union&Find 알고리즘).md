## 문제)
오늘은 새 학기 새로운 반에서 처음 시작하는 날이다. 현수네 반 학생은 N명이다. 현수는 각
학생들의 친구관계를 알고 싶다.
모든 학생은 1부터 N까지 번호가 부여되어 있고, 현수에게는 각각 두 명의 학생은 친구 관계
가 번호로 표현된 숫자쌍이 주어진다. 만약 (1, 2), (2, 3), (3, 4)의 숫자쌍이 주어지면 1번 학
생과 2번 학생이 친구이고, 2번 학생과 3번 학생이 친구, 3번 학생과 4번 학생이 친구이다.
그리고 1번 학생과 4번 학생은 2번과 3번을 통해서 친구관계가 된다.
학생의 친구관계를 나타내는 숫자쌍이 주어지면 특정 두 명이 친구인지를 판별하는 프로그램
을 작성하세요. 두 학생이 친구이면 “YES"이고, 아니면 ”NO"를 출력한다.

### 입력 설명
첫 번째 줄에 반 학생수인 자연수 N(1<=N<=1,000)과 숫자쌍의 개수인 M(1<=M<=3,000)이
주어지고, 다음 M개의 줄에 걸쳐 숫자쌍이 주어진다.
마지막 줄에는 두 학생이 친구인지 확인하는 숫자쌍이 주어진다.

### 출력 설명
첫 번째 줄에 “YES"또는 "NO"를 출력한다.

### 입력
9 7\
1 2\
2 3\
3 4\
4 5\
6 7\
7 8\
8 9\
3 8

### 출력
NO

### 모범 답안
``` Cpp
#include <iostream>
using namespace std;

// index = 학생의 번호
// value = index 학생의 집합 번호
int unf[1001]; 

// v라는 학생의 집합 번호를 찾아준다. 
// -> index값과 배열의 값이 같아야 종착지이다.
// -> 종착지가 곧 집합 번호이다.
// -> 따라서 해당 배열의 값까지 같은 집합으로 묶어준다.
int Find(int v) {
    if (v == unf[v]) return v;
    else return Find(unf[v]);
}

int Find2(int v) {
    if (v == unf[v]) return v;
    else return unf[v] = Find(unf[v]); // 경로를 압축
}

void Union(int a, int b) {
    a = Find(a);
    b = Find(b);
    if (a != b) unf[a] = b;
}

int main() {
    FILE* fp = nullptr;
    freopen_s(&fp, "input.txt", "rt", stdin);
    
    int n = 0, m = 0, a = 0, b = 0;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        unf[i] = i;
    }
    for (int i = 1; i <= m; i++) {
        cin >> a >> b;
        Union(a, b);
    }

    cin >> a >> b;
    a = Find(a);
    b = Find(b);
    if (a == b) cout << "YES";
    else cout << "NO";

    return 0;
}
```

### Disjoint-set 자료 구조
1) 2개의 집합에 같은 원소가 있다면 하나의 집합으로 만드는 것을 의미
2) Tree로 구현 -> 연결

### 회고
1. 상당히 어려운 Disjoint-set을 만났다.
2. 노드를 통해 각 데이터를 연결시켜서 하나의 집합으로 만드는 것에서부터 출발해서(Find 함수)
3. 경로를 압축시켜 조금 더 효율적인 구조가 되도록 만들어 주었다(Find2 함수)
4. 단순히 Find 함수만 사용을 하게 되면 배열의 index과 배열의 값이 같을 때까지 
5. 계속 재귀 탐색을 해야 하지만 경로를 압축시켜주면(`unf[v] = Find(unf[v])`)
6. 연결된 경로를 하나의 경로로 만들어줘서 조금 더 효울적인 자료구조가 된다.
7. 즉, {1, 2}, {2, 3}, {3, 4} -> {1, 2, 3, 4} 요게 1번 방식
8. {1, 2}, {2, 3}, {3, 4} -> {1, 4} 요게 2번 방식이다.