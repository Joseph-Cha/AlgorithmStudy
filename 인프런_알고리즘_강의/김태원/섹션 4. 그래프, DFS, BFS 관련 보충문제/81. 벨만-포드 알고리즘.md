## 문제)
N개의 도시가 주어지고, 각 도시들을 연결하는 도로와 해당 도로를 통행하는 비용이 주어질
때 한 도시에서 다른 도시로 이동하는데 쓰이는 비용의 최소값을 구하는 프로그램을 작성하세
요.

![image](https://user-images.githubusercontent.com/75019048/178995298-d6431851-69a3-4101-9983-15180c7e9055.png)



### 입력 설명
첫 번째 줄에는 도시의 수N(N<=100)과 도로수 M(M<=200)가 주어지고, M줄에 걸쳐 도로정보
와 비용이 주어진다. 만약 1번 도시와 2번도시가 연결되고 그 비용이 13이면 “1 2 13”으로
주어진다. 그 다음 마지막 줄에 출발도시와 도착도시가 주어진다. 

### 출력 설명
출발도시에서 도착도시까지 가는데 걸리는 최소비용을 출력한다. 음의 사이클이 존재할 경우
-1를 출력한다.

### 입력
5 7\
1 2 5\
1 3 4\
2 3 -3\
2 5 13\
3 4 5\
4 2 3\
4 5 7\
1 5

### 출력
14

### 모범 답안
``` Cpp
#include<bits/stdc++.h>
using namespace std;
int dist[101];
struct Edge {
    int s;  // 1번 정점
    int e;  // 2번 정점
    int val;// 간선 비용
    Edge(int a, int b, int c) {
        s = a;
        e = b;
        val = c;
    }
};

int main() {
    FILE* fp = nullptr;
    freopen_s(&fp, "input.txt", "rt", stdin);
    vector<Edge> Ed;
    int i = 0, n = 0, m = 0, a = 0, b = 0, c = 0, j = 0, s = 0, e = 0;
    for (i = 1; i <= m; i++) {
        cin >> a >> b >> c;
        Ed.push_back(Edge(a, b, c));
    }
    for (i = 1; i <= n; i++) {
        dist[i] = 21470000000;
    }
    // 출발 정점과 도착 정점 입력
    cin >> s >> e;
    dist[s] = 0;
    // 간선의 갯수를 1개씩 늘려가면서 판단 -> i갯수만큼의 간선을 사용해서 갈수 있는 거리를 판단
    for (i = 1; i < n; i++) { 
        // 현재 정점에서 다음 정점으로 가기 위한 반복문
        for (j = 0; j < Ed.size(); j++) {   
            int u = Ed[j].s;    // 현재 정점
            int v = Ed[j].e;    // 도착 정점
            int w = Ed[j].val;  // 간선 비용
            // 현재점이 무한대 거리면 x
            // 현재 정점까지 온 비용 + 다음 정점까지 가는 비용 < 다음 정점까지 가는 비용
            // -> 어떤 방식이 더 최소비용인지 판단해서 교체
            if (dist[u] != 214700000000 && dist[u] + w < dist[v]) {
                // dist에는 각 정점까지 가는 최소 비용이 저장되어 있다.
                dist[v] = dist[u] + w; 
            }
        }
    }
    // 간선의 갯수가 n개까지 있을 때 판단 (현재 i == n)
    // 간선의 갯수가 n개까지 있다면 음의 사이클이 있는 상태이다.
    for (j = 0; j < Ed.size(); j++) {
        int u = Ed[j].s;
        int v = Ed[j].e;
        int w = Ed[j].val;
        if (dist[u] != 2147000000 && dist[u] + w < dist[v]) {
            cout << "-1\n";
            exit(0);
        }
    }
    cout << dist[e];
    return 0;
}
```

### 벨만-포드 알고리즘
- 출발지에서 도착지까지 도달하는 데 걸리는 최소 비용을 구하는 알고리즘
- n개의 정점이 있다면 최대 n-1개 만큼의 간선이 있다고 가정
- (n-1개 보다 간선이 많으면 그건 최소 비용 간선의 갯수가 아니라고 판단)
- 해서 1, 2, 3, ... , n - 1개씩 간선을 늘려가면서 각 정점에 도달하는 데 필요한
- 최소 비용을 구하는 방식으로 구현한다.